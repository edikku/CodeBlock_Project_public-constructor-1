/**

Конструктор и деструктор классов в C++

Начнем с того, что когда мы создаем элементы (переменные) класса, мы не можем присвоить им значения в самом определении класса.
Компилятор выдаст ошибку. Поэтому нам необходимо создавать отдельный метод (так называемую set-функцию) класса,
    с помощью которого и будет происходить инициализация элементов.
При этом, если необходимо создать, к примеру, 20 объектов класса, то чтобы инициализировать элементы потребуется 20 раз вызвать set-функции.

Тут нам как раз сможет помочь конструктор класса. Кстати, конструктор (от слова construct — создавать) – это специальный метод класса,
    который предназначен для инициализации элементов класса некоторыми начальными значениями.

В отличии от конструктора, деструктор (от слова destruct — разрушать) — специальный метод класса,
    который служит для уничтожения элементов класса.
Чаще всего его используют тогда, когда в конструкторе,при создании объекта класса,
    динамически был выделен участок памяти и необходимо эту память очистить,
    если эти значения уже не нужны для дальнейшей работы программы.

Важно запомнить:

1. Конструктор и деструктор, мы всегда объявляем в разделе public;
2. При объявлении конструктора, тип данных возвращаемого значения не указывается, в том числе — void!!!;
3. У деструктора также нет типа данных для возвращаемого значения, к тому же деструктору нельзя передавать никаких параметров;
4. Имя класса и конструктора должно быть идентично;
5. Имя деструктора идентично имени конструктора, но с приставкой ~ ;
6. В классе допустимо создавать несколько конструкторов, если это необходимо.
    Имена, согласно пункту 2 нашего списка, будут одинаковыми.
    Компилятор будет их различать по передаваемым параметрам (как при перегрузке функций).
    Если мы не передаем в конструктор параметры, он считается конструктором по умолчанию;
7. Обратите внимание на то, что в классе может быть объявлен только один деструктор;

Сразу хочу привести пример, который доступно покажет, как работает конструктор:

Результат работы программы:

////////////////////////////////////////////////////////////////////////////////
// Работа конструктора при создании нового объекта:
// a = 0
// b = 0
//
// Введите целое число а: 34
// Введите целое число b: 67
// a = 34
// b = 67
//
// Работа конструктора при создании нового объекта:
// a = 0
// b = 0
////////////////////////////////////////////////////////////////////////////////

Как видно из результата работы программы, конструктор срабатывает сразу, при создании объектов класса,
    поэтому, явно вызывать конструктор не нужно, он сам «приходит» :)

Хочется еще добавить, что, как и обычным функциям, мы можем передавать конструктору параметры.
Через параметры, конструктору можно передавать любые данные, которые будут необходимы при инициализации объектов класса.

*/
# include <iostream>
using namespace std;

class AB //класс
{
    private:
    int a;
    int b;
    public:
    AB()    //это конструктор:  1) у конструктора нет типа возвращаемого значения! в том числе void!!!
    //   2) имя должно быть таким как и у класса (в нашем случае AB)
    {
        a = 0;//присвоим начальные значения переменным
        b = 0;
        cout << "Работа конструктора при создании нового объекта: " << endl;//и здесь же их отобразим на экран
        cout << "a = " << a << endl;
        cout << "b = " << b << endl << endl;
    }

    void setAB() // с помощью этого метода изменим начальные значения заданные конструктором
    {
        cout << "Введите целое число а: ";
        cin >> a;
        cout << "Введите целое число b: ";
        cin >> b;
    }

    void getAB() //выведем на экран измененные значения
    {
        cout << "a = " << a << endl;
        cout << "b = " << b << endl << endl;
    }
};

int main()
{
    setlocale(LC_ALL, "rus");

    AB obj1;     //конструктор сработает на данном этапе (во время создания объекта класса)

    obj1.setAB();   //присвоим новые значения переменным
    obj1.getAB();   //и выведем их на экран

    AB obj2;     //конструктор сработает на данном этапе (во время создания 2-го объекта класса)
return 0;
}
